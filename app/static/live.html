<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Live Deepfake Detection</title>
  <link rel="icon" id="pageFavicon" type="image/png" href="">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: #0F172A;
      color: #fff;
      min-height: 100vh;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      background: #1E293B;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }

    .header h1 {
      font-size: 20px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .header h1 .icon {
      width: 32px;
      height: 32px;
      background: rgba(129,140,248,0.2);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn-start {
      background: linear-gradient(135deg, #22C55E, #16A34A);
      color: white;
    }

    .btn-start:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(34,197,94,0.3); }

    .btn-stop {
      background: linear-gradient(135deg, #EF4444, #DC2626);
      color: white;
    }

    .btn-stop:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(239,68,68,0.3); }

    .btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none !important;
    }

    .btn-pip {
      background: rgba(129,140,248,0.12);
      border: 1px solid rgba(129,140,248,0.28);
      color: #818CF8;
    }
    .btn-pip:hover { background: rgba(129,140,248,0.22); transform: translateY(-1px); }
    .btn-pip.active {
      background: rgba(129,140,248,0.28);
      border-color: rgba(129,140,248,0.55);
      box-shadow: 0 0 12px rgba(129,140,248,0.2);
    }

    .main {
      display: flex;
      gap: 20px;
      padding: 20px;
      height: calc(100vh - 68px);
    }

    .video-panel {
      flex: 1;
      position: relative;
      background: #1E293B;
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.06);
    }

    #screenVideo {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
    }

    /* Face-box overlay ‚Äî sits directly on top of the video */
    #faceOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;   /* clicks pass through to video */
    }

    .placeholder {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: rgba(255,255,255,0.3);
    }

    .placeholder .big-icon { font-size: 64px; margin-bottom: 16px; }
    .placeholder p { font-size: 16px; }

    /* Floating verdict overlay */
    .verdict-overlay {
      position: absolute;
      top: 16px;
      right: 16px;
      padding: 12px 20px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 700;
      display: none;
      align-items: center;
      gap: 10px;
      backdrop-filter: blur(16px);
      z-index: 10;
      transition: all 0.3s ease;
    }

    .verdict-overlay.real {
      display: flex;
      background: rgba(34,197,94,0.2);
      border: 1px solid rgba(34,197,94,0.4);
      color: #22C55E;
    }

    .verdict-overlay.fake {
      display: flex;
      background: rgba(239,68,68,0.2);
      border: 1px solid rgba(239,68,68,0.4);
      color: #EF4444;
      animation: pulse-red 1.5s infinite;
    }

    .verdict-overlay.uncertain {
      display: flex;
      background: rgba(245,158,11,0.2);
      border: 1px solid rgba(245,158,11,0.4);
      color: #F59E0B;
    }

    .verdict-overlay.analyzing {
      display: flex;
      background: rgba(129,140,248,0.2);
      border: 1px solid rgba(129,140,248,0.4);
      color: #818CF8;
    }

    @keyframes pulse-red {
      0%, 100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.3); }
      50% { box-shadow: 0 0 20px 4px rgba(239,68,68,0.2); }
    }

    /* Side panel */
    .side-panel {
      width: 340px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      overflow-y: auto;
    }

    .card {
      background: #1E293B;
      border-radius: 14px;
      padding: 20px;
      border: 1px solid rgba(255,255,255,0.06);
    }

    .card h3 {
      font-size: 14px;
      color: rgba(255,255,255,0.5);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      font-size: 13px;
    }

    .stat-row .label { color: rgba(255,255,255,0.5); }
    .stat-row .value { font-weight: 600; }

    .log-entry {
      padding: 8px 12px;
      border-radius: 8px;
      margin-bottom: 6px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .log-entry.real { background: rgba(34,197,94,0.1); color: #22C55E; }
    .log-entry.fake { background: rgba(239,68,68,0.1); color: #EF4444; }
    .log-entry.uncertain { background: rgba(245,158,11,0.1); color: #F59E0B; }
    .log-entry.analyzing { background: rgba(129,140,248,0.1); color: #818CF8; }

    .log-container {
      max-height: 300px;
      overflow-y: auto;
    }

    .audio-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(129,140,248,0.1);
      font-size: 13px;
      color: #818CF8;
    }

    .audio-bars {
      display: flex;
      gap: 2px;
      align-items: flex-end;
      height: 16px;
    }

    .audio-bars span {
      width: 3px;
      background: #818CF8;
      border-radius: 2px;
      animation: audio-bar 0.8s ease-in-out infinite;
    }

    .audio-bars span:nth-child(1) { height: 6px; animation-delay: 0s; }
    .audio-bars span:nth-child(2) { height: 12px; animation-delay: 0.15s; }
    .audio-bars span:nth-child(3) { height: 8px; animation-delay: 0.3s; }
    .audio-bars span:nth-child(4) { height: 14px; animation-delay: 0.45s; }
    .audio-bars span:nth-child(5) { height: 10px; animation-delay: 0.6s; }

    @keyframes audio-bar {
      0%, 100% { transform: scaleY(1); }
      50% { transform: scaleY(0.4); }
    }

    .interval-select {
      background: #334155;
      color: white;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 13px;
    }

    #audioCanvas {
      width: 100%;
      height: 40px;
      border-radius: 8px;
      background: rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <h1>
      <span class="icon">üõ°Ô∏è</span>
      Live Deepfake Detection
    </h1>
    <div class="controls">
      <label style="font-size:13px; color:rgba(255,255,255,0.5);">
        Scan every:
        <select id="intervalSelect" class="interval-select">
          <option value="2000">2s</option>
          <option value="3000" selected>3s</option>
          <option value="5000">5s</option>
          <option value="10000">10s</option>
        </select>
      </label>
      <button id="btnPip" class="btn btn-pip" onclick="toggleWidget()" title="Float results in a mini window ‚Äî stays visible on other tabs">
        ‚ßâ Pop Out
      </button>
      <button id="btnStart" class="btn btn-start" onclick="startCapture()">
        ‚ñ∂ Start Capture
      </button>
      <button id="btnStop" class="btn btn-stop" onclick="stopCapture()" disabled>
        ‚ñ† Stop
      </button>
    </div>
  </div>

  <!-- Main layout -->
  <div class="main">
    <!-- Video panel -->
    <div class="video-panel">
      <video id="screenVideo" autoplay muted></video>
      <canvas id="faceOverlay"></canvas>
      <div id="placeholder" class="placeholder">
        <div class="big-icon">üñ•Ô∏è</div>
        <p>Click "Start Capture" to share your screen</p>
        <p style="font-size:13px; margin-top:8px; opacity:0.5">
          Select a window, tab, or entire screen
        </p>
      </div>
      <div id="verdictOverlay" class="verdict-overlay"></div>
    </div>

    <!-- Side panel -->
    <div class="side-panel">
      <!-- Status -->
      <div class="card">
        <h3>üìä Status</h3>
        <div class="stat-row">
          <span class="label">State</span>
          <span class="value" id="statState">Idle</span>
        </div>
        <div class="stat-row">
          <span class="label">Frames analyzed</span>
          <span class="value" id="statFrames">0</span>
        </div>
        <div class="stat-row">
          <span class="label">Fake detections</span>
          <span class="value" id="statFakes" style="color:#EF4444">0</span>
        </div>
        <div class="stat-row">
          <span class="label">Real detections</span>
          <span class="value" id="statReals" style="color:#22C55E">0</span>
        </div>
        <div class="stat-row">
          <span class="label">Avg confidence</span>
          <span class="value" id="statConfidence">-</span>
        </div>
      </div>

      <!-- Audio -->
      <div class="card">
        <h3>üéôÔ∏è Audio</h3>
        <div id="audioStatus">
          <div style="font-size:13px; color:rgba(255,255,255,0.4)">
            Audio capture starts with screen share
          </div>
        </div>
        <canvas id="audioCanvas" style="margin-top: 10px;"></canvas>
      </div>

      <!-- Log -->
      <div class="card" style="flex:1;">
        <h3>üìã Detection Log</h3>
        <div id="logContainer" class="log-container">
          <div class="log-entry analyzing">
            Waiting to start...
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden canvas for frame extraction -->
  <canvas id="frameCanvas" style="display:none;"></canvas>

  <script>
    // ---- Face overlay canvas ----
    const faceOverlay = document.getElementById('faceOverlay');
    const faceCtx = faceOverlay.getContext('2d');

    // Colour per verdict
    const VERDICT_COLOR = {
      real:      '#22C55E',
      fake:      '#EF4444',
      uncertain: '#F59E0B',
    };

    function drawFaceBox(bbox, prediction) {
      // Sync canvas size to its CSS display size
      faceOverlay.width  = faceOverlay.clientWidth;
      faceOverlay.height = faceOverlay.clientHeight;
      faceCtx.clearRect(0, 0, faceOverlay.width, faceOverlay.height);

      if (!bbox) return;

      // The video uses object-fit:contain, so we need the actual rendered rect
      const videoEl  = document.getElementById('screenVideo');
      const vw       = videoEl.videoWidth;
      const vh       = videoEl.videoHeight;
      const cw       = faceOverlay.clientWidth;
      const ch       = faceOverlay.clientHeight;

      if (!vw || !vh) return;

      // Letterbox / pillarbox offsets
      const scale    = Math.min(cw / vw, ch / vh);
      const offsetX  = (cw - vw * scale) / 2;
      const offsetY  = (ch - vh * scale) / 2;

      // Convert normalised bbox ‚Üí canvas pixels
      const rx = offsetX + bbox.x * vw * scale;
      const ry = offsetY + bbox.y * vh * scale;
      const rw = bbox.w * vw * scale;
      const rh = bbox.h * vh * scale;

      const color = VERDICT_COLOR[prediction.toLowerCase()] || '#818CF8';

      // Outer glow
      faceCtx.shadowColor  = color;
      faceCtx.shadowBlur   = 12;
      faceCtx.strokeStyle  = color;
      faceCtx.lineWidth    = 2.5;
      faceCtx.strokeRect(rx, ry, rw, rh);
      faceCtx.shadowBlur   = 0;

      // Corner accents (L-shaped brackets)
      const cs = Math.min(rw, rh) * 0.18;  // corner segment length
      faceCtx.lineWidth = 3.5;
      faceCtx.strokeStyle = color;

      const corners = [
        [rx,      ry,      cs,  0,  0, cs],   // top-left
        [rx + rw, ry,     -cs,  0,  0, cs],   // top-right
        [rx,      ry + rh, cs,  0,  0,-cs],   // bottom-left
        [rx + rw, ry + rh,-cs,  0,  0,-cs],   // bottom-right
      ];
      for (const [x, y, dx1, dy1, dx2, dy2] of corners) {
        faceCtx.beginPath();
        faceCtx.moveTo(x + dx1, y + dy1);
        faceCtx.lineTo(x, y);
        faceCtx.lineTo(x + dx2, y + dy2);
        faceCtx.stroke();
      }

      // Label pill above the box
      const label  = prediction.toUpperCase();
      const font   = 'bold 13px Inter, -apple-system, sans-serif';
      faceCtx.font = font;
      const tw     = faceCtx.measureText(label).width;
      const ph     = 22;
      const pw     = tw + 18;
      const px     = rx + (rw - pw) / 2;
      const py     = ry - ph - 6;

      faceCtx.fillStyle = color + 'CC';   // semi-transparent fill
      roundRect(faceCtx, px, py, pw, ph, 6);
      faceCtx.fill();

      faceCtx.fillStyle = '#fff';
      faceCtx.font      = font;
      faceCtx.textAlign = 'center';
      faceCtx.fillText(label, px + pw / 2, py + 15);
      faceCtx.textAlign = 'left';
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.arcTo(x + w, y, x + w, y + r, r);
      ctx.lineTo(x + w, y + h - r);
      ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
      ctx.lineTo(x + r, y + h);
      ctx.arcTo(x, y + h, x, y + h - r, r);
      ctx.lineTo(x, y + r);
      ctx.arcTo(x, y, x + r, y, r);
      ctx.closePath();
    }

    function clearFaceBox() {
      faceOverlay.width  = faceOverlay.clientWidth;
      faceOverlay.height = faceOverlay.clientHeight;
      faceCtx.clearRect(0, 0, faceOverlay.width, faceOverlay.height);
    }

    // ---- State ----
    let stream = null;
    let audioStream = null;
    let mediaRecorder = null;
    let audioChunks = [];
    let scanInterval = null;
    let frameCount = 0;
    let fakeCount = 0;
    let realCount = 0;
    let totalConfidence = 0;
    let isAnalyzing = false;
    let audioContext = null;
    let analyserNode = null;
    let animFrameId = null;

    const API_BASE = window.location.origin; // same server

    // ---- Elements ----
    const video = document.getElementById('screenVideo');
    const placeholder = document.getElementById('placeholder');
    const verdictOverlay = document.getElementById('verdictOverlay');
    const logContainer = document.getElementById('logContainer');
    const canvas = document.getElementById('frameCanvas');
    const ctx = canvas.getContext('2d');
    const audioCanvas = document.getElementById('audioCanvas');
    const audioCtx2d = audioCanvas.getContext('2d');

    // ---- Start capture ----
    async function startCapture() {
      try {
        // Request screen + audio
        stream = await navigator.mediaDevices.getDisplayMedia({
          video: { cursor: 'always' },
          audio: true  // capture tab/system audio
        });

        video.srcObject = stream;
        placeholder.style.display = 'none';

        document.getElementById('btnStart').disabled = true;
        document.getElementById('btnStop').disabled = false;
        document.getElementById('statState').textContent = 'üü¢ Capturing';

        // Check if audio track exists
        const audioTracks = stream.getAudioTracks();
        if (audioTracks.length > 0) {
          startAudioVisualization(stream);
          startAudioRecording(stream);
          document.getElementById('audioStatus').innerHTML = `
            <div class="audio-indicator">
              <div class="audio-bars">
                <span></span><span></span><span></span><span></span><span></span>
              </div>
              Recording audio...
            </div>
          `;
        } else {
          document.getElementById('audioStatus').innerHTML = `
            <div style="font-size:13px; color:#F59E0B">
              ‚ö†Ô∏è No audio ‚Äî share a browser tab for audio capture
            </div>
          `;
        }

        // Start scanning frames
        const interval = parseInt(document.getElementById('intervalSelect').value);
        scanInterval = setInterval(analyzeFrame, interval);

        // Handle stream ending (user clicks "Stop sharing")
        stream.getVideoTracks()[0].onended = () => stopCapture();

        addLog('analyzing', 'üü¢ Capture started ‚Äî scanning every ' +
          (interval / 1000) + 's');
      } catch (err) {
        console.error('Screen capture failed:', err);
        addLog('uncertain', '‚ùå Screen capture cancelled or denied');
      }
    }

    // ---- Stop capture ----
    function stopCapture() {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }

      if (scanInterval) {
        clearInterval(scanInterval);
        scanInterval = null;
      }

      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }

      if (animFrameId) {
        cancelAnimationFrame(animFrameId);
        animFrameId = null;
      }

      video.srcObject = null;
      placeholder.style.display = '';
      verdictOverlay.className = 'verdict-overlay';
      verdictOverlay.style.display = 'none';
      clearFaceBox();

      document.getElementById('btnStart').disabled = false;
      document.getElementById('btnStop').disabled = true;
      document.getElementById('statState').textContent = '‚èπ Stopped';

      addLog('analyzing', '‚èπ Capture stopped');
      resetTabTitle();

      // If we have audio, offer download
      if (audioChunks.length > 0) {
        const blob = new Blob(audioChunks, { type: 'audio/webm' });
        const url = URL.createObjectURL(blob);
        addLog('analyzing',
          `üéôÔ∏è Audio recorded ‚Äî <a href="${url}" download="captured_audio.webm" style="color:#818CF8">Download</a>`
        );
        audioChunks = [];
      }
    }

    // ---- Analyze a single frame ----
    async function analyzeFrame() {
      if (isAnalyzing || !stream) return;
      isAnalyzing = true;

      try {
        // Extract frame from video
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0);

        // Convert to blob
        const blob = await new Promise(resolve =>
          canvas.toBlob(resolve, 'image/jpeg', 0.85)
        );

        if (!blob) {
          isAnalyzing = false;
          return;
        }

        // Show analyzing state
        verdictOverlay.className = 'verdict-overlay analyzing';
        verdictOverlay.textContent = 'üîç Analyzing...';

        // Send to API
        const formData = new FormData();
        formData.append('file', blob, 'frame.jpg');

        const response = await fetch(`${API_BASE}/predict`, {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.detail || 'API error');
        }

        const result = await response.json();
        frameCount++;

        // Map new response shape ‚Äî verdict is REAL/FAKE/UNCERTAIN (uppercase)
        const verdict = (result.verdict || 'UNCERTAIN').toLowerCase();
        const pFake = result.final_p_fake ?? 0.5;
        const conf = (Math.max(pFake, 1 - pFake) * 100).toFixed(1);
        const band = result.confidence_band || '';
        verdictOverlay.className = `verdict-overlay ${verdict}`;
        verdictOverlay.innerHTML = `${getEmoji(verdict)} ${result.verdict} ‚Äî ${conf}% <small>${band}</small>`;

        // Draw face bounding box on the video overlay
        const bbox = result.signals ? result.signals.face_bbox : null;
        const faceFound = result.signals ? result.signals.face_found : false;
        drawFaceBox(bbox, result.verdict);

        // Update stats
        if (verdict === 'fake') fakeCount++;
        else if (verdict === 'real') realCount++;
        totalConfidence += parseFloat(conf);

        document.getElementById('statFrames').textContent = frameCount;
        document.getElementById('statFakes').textContent = fakeCount;
        document.getElementById('statReals').textContent = realCount;
        document.getElementById('statConfidence').textContent =
          (totalConfidence / frameCount).toFixed(1) + '%';

        // Add log entry
        const time = new Date().toLocaleTimeString();
        const faceInfo = faceFound ? '‚ú¶ face' : '‚ö¨ no face';
        const reasons = result.reasons ? result.reasons.join(', ') : '';
        addLog(verdict,
          `${getEmoji(verdict)} ${time} ‚Äî ${result.verdict} (${conf}%) ${faceInfo}${reasons ? ' ¬∑ ' + reasons : ''}`
        );

        // ‚îÄ‚îÄ Always-visible feedback (tab title, favicon, floating widget) ‚îÄ‚îÄ
        updateTabTitle(result.verdict, conf);
        updateFavicon(result.verdict);
        // Render face box onto a thumbnail and push to floating widget
        const thumbDataUrl = createFaceThumbnail(bbox, result.verdict);
        updateWidget(result.verdict, pFake, band, time, thumbDataUrl);

      } catch (err) {
        console.error('Analysis error:', err);
        addLog('uncertain', `‚ö†Ô∏è Error: ${err.message}`);
      }

      isAnalyzing = false;
    }

    // ---- Audio recording ----
    function startAudioRecording(mediaStream) {
      try {
        mediaRecorder = new MediaRecorder(mediaStream, {
          mimeType: 'audio/webm;codecs=opus'
        });
        audioChunks = [];

        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) audioChunks.push(e.data);
        };

        mediaRecorder.start(1000); // collect chunks every 1s
      } catch (err) {
        console.error('Audio recording failed:', err);
      }
    }

    // ---- Audio visualization ----
    function startAudioVisualization(mediaStream) {
      try {
        audioContext = new AudioContext();
        const source = audioContext.createMediaStreamSource(mediaStream);
        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 256;
        source.connect(analyserNode);

        drawAudioWaveform();
      } catch (err) {
        console.error('Audio viz failed:', err);
      }
    }

    function drawAudioWaveform() {
      if (!analyserNode) return;

      const bufferLength = analyserNode.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);

      function draw() {
        animFrameId = requestAnimationFrame(draw);
        analyserNode.getByteFrequencyData(dataArray);

        const w = audioCanvas.width = audioCanvas.clientWidth;
        const h = audioCanvas.height = audioCanvas.clientHeight;
        audioCtx2d.clearRect(0, 0, w, h);

        const barWidth = (w / bufferLength) * 2;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
          const barHeight = (dataArray[i] / 255) * h;
          const hue = 240 + (dataArray[i] / 255) * 60; // blue to purple
          audioCtx2d.fillStyle = `hsla(${hue}, 70%, 60%, 0.8)`;
          audioCtx2d.fillRect(x, h - barHeight, barWidth - 1, barHeight);
          x += barWidth;
        }
      }

      draw();
    }

    // ---- Helpers ----
    function getEmoji(pred) {
      switch (pred) {
        case 'fake': return 'üö®';
        case 'real': return '‚úÖ';
        default: return '‚ùì';
      }
    }

    function addLog(type, message) {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.innerHTML = message;
      logContainer.prepend(entry);

      // Keep max 50 entries
      while (logContainer.children.length > 50) {
        logContainer.removeChild(logContainer.lastChild);
      }
    }

    // =========================================================================
    // FLOATING WIDGET  (Document PiP ‚Üí popup fallback)
    // Stays visible on top of all other windows / tabs while you browse.
    // =========================================================================

    let widgetWindow = null;   // reference to PiP or popup window

    // CSS injected into both Document PiP and popup
    const WIDGET_CSS = `
      * { margin:0; padding:0; box-sizing:border-box; }
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #0F172A; color: #fff;
        height: 100vh; display: flex; flex-direction: column; overflow: hidden;
        user-select: none;
      }
      .w-header {
        background: #1E293B; padding: 7px 12px;
        font-size: 10px; color: rgba(255,255,255,0.35);
        text-transform: uppercase; letter-spacing: 1.2px;
        display: flex; align-items: center; justify-content: space-between;
        border-bottom: 1px solid rgba(255,255,255,0.05);
        flex-shrink: 0;
      }
      .w-header .dot { width: 7px; height: 7px; border-radius: 50%; background: #818CF8; flex-shrink:0; }
      /* Thumbnail ‚Äî hidden until first frame arrives */
      .w-thumb-wrap {
        flex-shrink: 0; overflow: hidden; background: #000;
        border-bottom: 1px solid rgba(255,255,255,0.05);
        display: none;
      }
      .w-thumb-wrap img { width: 100%; height: auto; display: block; }
      /* Info section */
      .w-main {
        flex: 1; display: flex; flex-direction: column;
        align-items: stretch; justify-content: center;
        padding: 10px 14px; gap: 8px; transition: background 0.4s;
      }
      /* Row 1: emoji+verdict on left, band badge on right */
      .w-verdict-row {
        display: flex; align-items: center; justify-content: space-between; gap: 6px;
      }
      .w-verdict {
        font-size: 24px; font-weight: 800; letter-spacing: 2px;
        transition: color 0.3s; white-space: nowrap;
      }
      .w-badge {
        font-size: 9px; font-weight: 700; letter-spacing: 0.8px;
        padding: 3px 9px; border-radius: 20px; text-transform: uppercase;
        white-space: nowrap; flex-shrink: 0;
      }
      /* Row 2: bar + percentage */
      .w-bar-row {
        display: flex; align-items: center; gap: 8px;
      }
      .w-track {
        flex: 1; height: 5px; background: rgba(255,255,255,0.08);
        border-radius: 3px; overflow: hidden;
      }
      .w-fill { height: 100%; border-radius: 3px; transition: width 0.4s ease, background-color 0.4s ease; }
      .w-pct  { font-size: 12px; font-weight: 700; min-width: 38px; text-align: right; }
      /* Timestamp */
      .w-time { font-size: 9px; color: rgba(255,255,255,0.25); }
      /* Footer stats */
      .w-footer {
        background: #1E293B; padding: 6px 14px;
        display: flex; justify-content: space-around;
        font-size: 10px; color: rgba(255,255,255,0.45);
        border-top: 1px solid rgba(255,255,255,0.05);
        flex-shrink: 0;
      }
      .w-stat   { display: flex; gap: 4px; align-items: center; }
      .w-stat b { color: #fff; font-weight: 700; }
    `;

    // HTML injected into widget document
    const WIDGET_HTML = `
      <div class="w-header">
        <span>üõ° Deepfake Detector</span>
        <div class="dot" id="wDot"></div>
      </div>
      <div class="w-thumb-wrap" id="wThumbWrap">
        <img id="wThumb" alt="">
      </div>
      <div class="w-main" id="wMain">
        <div class="w-verdict-row">
          <span class="w-verdict" id="wVerdict" style="color:#818CF8">‚è≥ Waiting</span>
          <span class="w-badge" id="wBand"
                style="background:rgba(129,140,248,.15);color:#818CF8">‚Äî</span>
        </div>
        <div class="w-bar-row">
          <div class="w-track">
            <div class="w-fill" id="wBar" style="width:0%;background:#818CF8"></div>
          </div>
          <span class="w-pct" id="wPct" style="color:#818CF8">‚Äî</span>
        </div>
        <div class="w-time" id="wTime">Waiting for scan‚Ä¶</div>
      </div>
      <div class="w-footer">
        <div class="w-stat">üö® <b id="wFakes">0</b></div>
        <div class="w-stat">‚úÖ <b id="wReals">0</b></div>
        <div class="w-stat">üìä <b id="wFrames">0</b></div>
      </div>
    `;

    function _setupWidgetDoc(doc) {
      const style = doc.createElement('style');
      style.textContent = WIDGET_CSS;
      doc.head.appendChild(style);
      doc.body.innerHTML = WIDGET_HTML;
    }

    async function toggleWidget() {
      if (widgetWindow && !widgetWindow.closed) {
        widgetWindow.close();
        widgetWindow = null;
        _refreshPipBtn();
        return;
      }

      // ‚îÄ‚îÄ Document Picture-in-Picture (Chrome 116+) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if ('documentPictureInPicture' in window) {
        try {
          const pip = await window.documentPictureInPicture.requestWindow({
            width: 290, height: 300,
          });
          _setupWidgetDoc(pip.document);
          widgetWindow = pip;
          pip.addEventListener('pagehide', () => { widgetWindow = null; _refreshPipBtn(); });
          _refreshPipBtn();
          return;
        } catch (e) {
          // user dismissed or browser rejected ‚Äî fall through to popup
        }
      }

      // ‚îÄ‚îÄ Popup fallback ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const popup = window.open(
        '', 'deepfake-widget',
        'width=290,height=300,toolbar=no,menubar=no,location=no,status=no,resizable=yes'
      );
      if (!popup) {
        addLog('uncertain', '‚ö†Ô∏è Popup blocked ‚Äî allow popups for this site to use the widget.');
        return;
      }
      popup.document.open();
      popup.document.write(`<!DOCTYPE html><html><head><meta charset="UTF-8">
        <title>Deepfake Widget</title>
        <style>${WIDGET_CSS}</style></head><body>${WIDGET_HTML}</body></html>`);
      popup.document.close();
      widgetWindow = popup;
      popup.addEventListener('beforeunload', () => { widgetWindow = null; _refreshPipBtn(); });
      _refreshPipBtn();
    }

    function _refreshPipBtn() {
      const btn = document.getElementById('btnPip');
      if (!btn) return;
      const open = widgetWindow && !widgetWindow.closed;
      btn.textContent = open ? '‚úï Close Widget' : '‚ßâ Pop Out';
      btn.classList.toggle('active', open);
    }

    // Update the floating widget after each scan
    function updateWidget(verdict, pFake, band, time, thumbDataUrl) {
      if (!widgetWindow || widgetWindow.closed) return;

      const doc = widgetWindow.document;
      const colors = { REAL: '#22C55E', FAKE: '#EF4444', UNCERTAIN: '#F59E0B' };
      const bgTints = {
        REAL:      'rgba(34,197,94,0.07)',
        FAKE:      'rgba(239,68,68,0.10)',
        UNCERTAIN: 'rgba(245,158,11,0.08)',
      };
      const emojis   = { REAL: '‚úÖ', FAKE: 'üö®', UNCERTAIN: '‚ùì' };
      const color    = colors[verdict]  || '#818CF8';
      const bgTint   = bgTints[verdict] || 'transparent';
      const emoji    = emojis[verdict]  || '‚è≥';
      const conf     = (Math.max(pFake, 1 - pFake) * 100).toFixed(1);
      const barPct   = (pFake * 100).toFixed(1);

      const $ = id => doc.getElementById(id);
      if (!$('wVerdict')) return;  // doc not ready yet

      // ‚îÄ‚îÄ Thumbnail (face box drawn on it, no label ‚Äî verdict shown below) ‚îÄ‚îÄ
      const thumbWrap = $('wThumbWrap');
      const thumbImg  = $('wThumb');
      if (thumbWrap && thumbImg) {
        if (thumbDataUrl) {
          thumbImg.src            = thumbDataUrl;
          thumbWrap.style.display = 'block';
        } else {
          thumbWrap.style.display = 'none';
        }
      }

      // ‚îÄ‚îÄ Info section ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      $('wMain').style.background     = bgTint;
      $('wVerdict').textContent        = emoji + ' ' + verdict;
      $('wVerdict').style.color        = color;
      $('wBand').textContent           = band || '‚Äî';
      $('wBand').style.background      = color + '22';
      $('wBand').style.color           = color;
      $('wBar').style.width            = barPct + '%';
      $('wBar').style.backgroundColor  = color;
      $('wPct').textContent            = conf + '%';
      $('wPct').style.color            = color;
      $('wTime').textContent           = 'Updated ' + time;
      $('wFakes').textContent          = fakeCount;
      $('wReals').textContent          = realCount;
      $('wFrames').textContent         = frameCount;

      // Pulse the dot
      const dot = $('wDot');
      if (dot) {
        dot.style.background = color;
        dot.style.boxShadow  = `0 0 6px ${color}`;
        setTimeout(() => { if (dot) dot.style.boxShadow = 'none'; }, 600);
      }
    }

    // Build a thumbnail (data URL) of the current frame with the face box drawn on it.
    // Uses the already-captured `canvas` (frameCanvas) as the source.
    function createFaceThumbnail(faceBox, verdict) {
      if (!canvas.width || !canvas.height) return null;

      const tw = 290, th = Math.round(290 * canvas.height / canvas.width);
      const tc = document.createElement('canvas');
      tc.width = tw; tc.height = th;
      const tx = tc.getContext('2d');

      // Draw the captured frame
      tx.drawImage(canvas, 0, 0, tw, th);

      if (!faceBox) return tc.toDataURL('image/jpeg', 0.8);

      const colors = { REAL: '#22C55E', FAKE: '#EF4444', UNCERTAIN: '#F59E0B' };
      const color  = colors[verdict] || '#818CF8';

      // bbox is normalised (0-1) relative to original video ‚Äî map to thumbnail pixels
      const rx = faceBox.x * tw;
      const ry = faceBox.y * th;
      const rw = faceBox.w * tw;
      const rh = faceBox.h * th;

      // Glow rect
      tx.shadowColor  = color;
      tx.shadowBlur   = 10;
      tx.strokeStyle  = color;
      tx.lineWidth    = 2;
      tx.strokeRect(rx, ry, rw, rh);
      tx.shadowBlur   = 0;

      // Corner L-brackets
      const cs = Math.min(rw, rh) * 0.20;
      tx.lineWidth   = 3;
      const corners  = [
        [rx,      ry,      cs,  0,  0, cs],
        [rx + rw, ry,     -cs,  0,  0, cs],
        [rx,      ry + rh, cs,  0,  0,-cs],
        [rx + rw, ry + rh,-cs,  0,  0,-cs],
      ];
      for (const [x, y, dx1, dy1, dx2, dy2] of corners) {
        tx.beginPath();
        tx.moveTo(x + dx1, y + dy1);
        tx.lineTo(x, y);
        tx.lineTo(x + dx2, y + dy2);
        tx.stroke();
      }

      return tc.toDataURL('image/jpeg', 0.80);
    }

    // =========================================================================
    // TAB TITLE + FAVICON  (always-on, visible in any tab strip)
    // =========================================================================
    const _faviconCanvas = document.createElement('canvas');
    _faviconCanvas.width = _faviconCanvas.height = 32;

    function updateTabTitle(verdict, conf) {
      const e = { REAL: '‚úÖ', FAKE: 'üö®', UNCERTAIN: '‚ùì' }[verdict] || 'üîç';
      document.title = `${e} ${verdict} ${conf}% ‚Äî Deepfake Detector`;
    }

    function updateFavicon(verdict) {
      const colors = { REAL: '#22C55E', FAKE: '#EF4444', UNCERTAIN: '#F59E0B' };
      const marks  = { REAL: '‚úì',       FAKE: '!',        UNCERTAIN: '?' };
      const color  = colors[verdict] || '#818CF8';
      const mark   = marks[verdict]  || '‚Ä¶';

      const c = _faviconCanvas;
      const x = c.getContext('2d');
      x.clearRect(0, 0, 32, 32);

      // Circle background
      x.fillStyle = color;
      x.beginPath(); x.arc(16, 16, 15, 0, Math.PI * 2); x.fill();

      // Inner ring
      x.strokeStyle = 'rgba(255,255,255,0.25)';
      x.lineWidth = 1.5;
      x.beginPath(); x.arc(16, 16, 13, 0, Math.PI * 2); x.stroke();

      // Character
      x.fillStyle = '#fff';
      x.font = 'bold 16px sans-serif';
      x.textAlign = 'center';
      x.textBaseline = 'middle';
      x.fillText(mark, 16, 17);

      const link = document.getElementById('pageFavicon');
      if (link) link.href = c.toDataURL('image/png');
    }

    function resetTabTitle() {
      document.title = 'Live Deepfake Detection';
      const link = document.getElementById('pageFavicon');
      if (link) link.href = '';
    }
  </script>
</body>
</html>
